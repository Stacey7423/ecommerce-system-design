# ER-диаграмма базы данных заказов

## Задача:
Спроектировать ER-диаграмму с учётом следующих вводных. Состав полей таблиц указать на своё усмотрение. В базе данных есть таблица orders со следующими полями: id (идентификатор заказа), name (название заказа), town (адрес доставки заказа), price (цена заказа), customer_id (идентификатор покупателя);
Другие таблицы: towns (справочник адресов), items (товары), customers (покупатели). Между orders и items предполагается связь многие-ко-многим.

## Таблицы, поля:
- `orders`: `id` (PK), name (название заказа), `town_id` (FK для связи с таблицей towns), `price` (стоимость заказа), `customer_id` (FK для связи с таблицей customers), `order_date` (дата оформления заказа);
- `towns`: `id` (PK), `name` (название города адреса доставки);
- `customers`: `id` (PK), `name` (логин покупателя), `phone` (номер телефона покупателя), `email` (адрес электронной почты покупателя);
- `items`: `id` (PK), `name` (название товара), `current_price` (текущая цена единицы товара), `description` (описание товара);
- `orders_items`: `order_id` (часть составного PK, FK для связи с таблицей orders), `item_id` (часть составного PK, FK для связи с таблицей items), `quantity` (количество единиц товара в позиции заказа), `unit_price` (цена единицы товара в позиции заказа в момент оформления заказа)

## Связи между таблицами:
- `orders (town_id)` ->` towns (id)` (1:M)
- `orders (customer_id)` -> `customers (id)` (1:M)
- `orders (id)` -> `orders_items (order_id)` (1:M)
- `items (id)` -> `orders_items (items_id)` (1:M)

## Описание:
1.	Диаграмму спроектировала в draw.io.
2.	Т.к. база данных состоит из таблиц, спроектирована даталогическая модель для реляционной БД по нотации Мартина.
3.	Вместо town в таблице orders указан внешний ключ town_id (для соблюдения 2НФ, 3НФ), это устраняет избыточность данных (названия городов хранятся только в справочнике), позволяет исключить ошибки ввода и аномалии при обновлении данных (если в справочнике towns изменится название города, не нужно будет обновлять town во всех связанных заказах).
4.	Для отображения связи многие-ко-многим между orders и items создана вспомогательная таблица orders_items, которая также отражает сущность позиции заказа. Первичный ключ таблицы orders_items составной, состоит из ключей order_id, item_id.
5.	Добавлены (как допущения, предварительно это нужно обсуждать) атрибут order_date в таблицу orders, атрибуты quantity, unit_price в таблицу orders_items для отображения количества единиц товара в позиции заказа и цену единицы товара на момент заказа (можно будет вывести в запросе стоимость заказа каждой позиции). В таблице customers отображены также атрибуты name, phone, email. В таблице items указан атрибуты name (название товара), description (описание товара) и current_price – текущая цена товара (на момент последнего обновления). Дополнительно можно указать атрибуты регион, страна для справочника адресов, в таблице покупателей указать дату регистрации, для товаров указать ключевые слова, категории товаров (зависит от целей использования БД, целевых метрик).
6.	Отображены следующие связи между таблицами:
*	orders (town_id) – towns (id): в каждом заказе только один адрес доставки, но в каждом городе может быть от 0 до нескольких заказов;
*	orders (customer_id) – customers (id): каждый заказ создаётся только одним покупателем (допущение, что заказ формируется одним лицом в программе), при этом покупатель может иметь от 0 до нескольких заказов;
*	orders (id) – orders_items (order_id): в заказе может быть от 0 до нескольких позиций товаров (связь заказ-товар), но каждая позиция заказа относится к конкретному заказу;
*	items (id) – orders_items (item_id): товары могут быть как позиции в разных заказах, но каждая позиция содержит конкретный товар.
